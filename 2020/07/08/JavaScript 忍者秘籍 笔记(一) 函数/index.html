<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="以中有足乐者，不知口体之奉不若人也"><title>JavaScript 忍者秘籍 阅读笔记(一) | zZZ</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JavaScript 忍者秘籍 阅读笔记(一)</h1><a id="logo" href="/.">zZZ</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">JavaScript 忍者秘籍 阅读笔记(一)</h1><div class="post-meta">Jul 8, 2020<span> | </span><span class="category"><a href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a></span></div><div class="post-content"><p>JavaScript 函数</p>
<a id="more"></a>
<h3 id="何为函数"><a href="#何为函数" class="headerlink" title="何为函数"></a>何为函数</h3><p>在js中函数作为第一对象拥有和其他对象类型同样的功能：</p>
<ul>
<li>通过字面量创建</li>
<li>赋值给变量</li>
<li>作为函数参数传递</li>
<li>作为函数结果返回</li>
<li>赋值给属性和方法</li>
</ul>
<p>函数创建： 函数声明，函数表达式，箭头函数， 函数生成器。</p>
<p>函数声明与函数表达式区别：</p>
<ul>
<li>函数声明必须要有函数名并且必须作为一个独立的语句存在</li>
<li>函数表达式可以没有函数名，但是必须作为其他语句的一部分</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">fn()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span> (<span class="params"></span>) </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="built_in">console</span>.log(<span class="string">'函数声明存在变量提升'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn1 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'函数表达式'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 立即执行函数，用括号包起来只是为了让JavaScript解析是不将其作为函数声明而是一个表达式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">i</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(i)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">&#125;)(<span class="number">3</span>)</span></pre></td></tr></table></figure>



<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>函数调用时存在两个隐式参数：argments和this。 argments是一个类数组，有length属性当不具备数组的内置方法。this值函数上下文，函数的定义方式和调用方式决定this的取值。</p>
<p>函数调用的方式：</p>
<ul>
<li>作为函数调用: fn() 非严格this 指向 全局window对象，严格模式指向 undefined</li>
<li>作为属性方法调用：a.fn() this指向调用函数的对象</li>
<li>作为构造函数调用: new fn() this 指向新创建的对象</li>
<li>通过apply，call调用: 二者之存在第二个参数不同。 this 指向一个参数</li>
</ul>
<p>箭头函数自身没有this，this在会继承箭头函数创建时的上下文环境</p>
<p>bind的方法：任何形式调用的函数都可以使用，bind 会创建一个新函数并绑定到bind方法传入的参数上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//bind和apply， call 区别</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">count</span> (<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        result += <span class="built_in">arguments</span>[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">this</span>.result = result;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n1 = &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n2 = &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n3 = &#123;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">count.call(n1,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">ni.result <span class="comment">// 10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">count.apply(n2,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">n2.result <span class="comment">// 10</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">count.bind(n3,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">n3.result <span class="comment">// undefined</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">count.bind(n3,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// apply与call 会执行函数并返回函数结果，而bind会创建一个新函数并返回新函数，新函数的this指向bind的第一个参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">n3.result <span class="comment">// 10</span></span></pre></td></tr></table></figure>



<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 实现过程</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFN</span> (<span class="params">fn,...resParameters</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> newObj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">   fn._proto_ = newObj.prototype;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> res = fn.apply(newObj,resParameters);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">return</span> res <span class="keyword">instanceof</span> object ? res : newObj <span class="comment">// 根据函数结果类型，new返回不同</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动实现apply</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.apply1 = <span class="function"><span class="keyword">function</span>(<span class="params">content, arg</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    content.fn = <span class="keyword">this</span>; <span class="comment">// 在目标对象上创建一个函数 然后指向调用函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> res = content.fn(...arg); <span class="comment">// 调用创建的函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">delete</span> content.fn(); <span class="comment">// 删除目标对象上的fn；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> res</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// call 与apply 只是后续参数不同处理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 手动实现bind (利用apply)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.bind = <span class="function"><span class="keyword">function</span>(<span class="params">content,...arg</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> _me = <span class="keyword">this</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">let</span> bindFN = <span class="function"><span class="keyword">function</span> (<span class="params">params</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">       <span class="keyword">return</span> _me.apply(content,arg.concat(params)) </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">       <span class="comment">// 合并两处参数 note 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">   &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">   <span class="keyword">return</span> bindFN</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// note 1 合并两处参数是为了满足一下需求,调用bind返回函数时能接受到调用时的参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> =&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    school: <span class="string">'High school'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">get</span>: function fn(name,age)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    	<span class="built_in">console</span>.log(age,name,<span class="keyword">this</span>.school)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">	school: <span class="string">'五道口'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bindfn = fn.bind(obj,<span class="string">'43'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">bindfn(); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">bindfn(<span class="string">'12'</span>);</span></pre></td></tr></table></figure>

<h3 id="闭包与函数作用域"><a href="#闭包与函数作用域" class="headerlink" title="闭包与函数作用域"></a>闭包与函数作用域</h3><p>闭包允许函数访问函数外部变量。在非严格模式下，全局定义一个变量，声明一个函数，并且在函数内部返回或操作全局作用于的变量就会形成一个闭包。    </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">'joker'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outerFn</span> (<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(name)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">outerFn();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这种情况下就会创建一个闭包，不过因为这里的全局作用域为winodw，在应用运行的情况下永远不会被销毁name变量也一直能访问所以不会觉得奇怪。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> later;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">outerFn</span> (<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">     <span class="keyword">let</span> innerValue = <span class="string">'XXX'</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">innerFn</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">         <span class="built_in">console</span>.log(innerValue)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  	later = innerFn;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"> &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">outerFn();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将outerFn函数内部函数inneFn赋值给外部变量later；</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">later();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在outeFn 函数外部作用域是没办法直接访问内部函数的，只能通过later</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//这样做之后即使outeFn作用域已经被销毁，之后在执行内部函数一样能访问内部变量。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是因为外部函数在创建内部函数时形成了一个闭包，这闭包包括了内部函数声明时作用域下的所有变量。所以调用later时能通过闭包访问到声明时作用域已经消失的变量innerValue.</span></span></pre></td></tr></table></figure>

<p>闭包应用：</p>
<ul>
<li>模拟对象的私有化属性</li>
<li>处理回调函数</li>
</ul>
<p>函数作用域:</p>
<ul>
<li>函数作用域是层级的,外层作用域不能访问内层变量，反之可以。</li>
<li>js引擎通过执行上下文来跟踪函数的执行，每次调用函数的时候都会创建一个新的函数执行上下文推入全局调用栈道顶端，执行之后会推出。</li>
<li>js使用的是词法作用域，所以是先注册在当前作用域下声明变量和函数。之后执行函数时如何执行会取决变量的类型以及环境类型（全局环境，函数环境，块级作用域）</li>
</ul>
<h3 id="生成器Generator和promise"><a href="#生成器Generator和promise" class="headerlink" title="生成器Generator和promise"></a>生成器Generator和promise</h3><p>生成器函数是一种异步解决方案。生成器通过在function 关键词后加一个星号*来定义，并且在生成器函数体内，根据关键字 <code>yield</code> 来生成一个值并挂起生成器的执行。生成器的调用会得到一个迭代器，此迭代器会向暴露一个<code>next</code>方法，<code>next</code>方法会返回一个对象包含<code>value</code>，<code>done</code> 属性。其中value值会设置为<code>yield</code>的返回值。如果生成器没有可以执行到<code>next</code>的时候<code>value</code>会被设置为<code>undefined</code>，</p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise是es6新的内置构造函数，用来处理异步函数。 利用内置构造函数promise创建一个promise函数需要闯入一个函数，并且传入函数内置两个参数：resolve，reject。resolve 表示promise 完成状态（fulfilled），reject 将promise 状态转为失败（rejected）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ninjaPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        resolve(<span class="string">'执行成功'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    &#125;,<span class="number">100</span>)；</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ninjaPromise.then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(res) <span class="comment">// 执行成功</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">&#125;,(rej)=&gt;&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(rej) <span class="comment">// rej = 构建promise函数时传入函数内置参reject函数的参数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;)</span></pre></td></tr></table></figure>

<p><code>Promise</code>对象内置一个<code>then</code>方法，可以传入两个函数，第一个是成功的回调函数，后一个为失败的回调函数。<code>then</code>会返回一个<code>Promise</code>对象，并且该<code>Promise</code>对象状态为<code>fulfilled</code>。</p>
<p><code>Promise</code>支持链式调用一个<code>catch</code>方法它与<code>then</code>函数的第二个函数参数一样在<code>Promise</code>为rejected状态时执行。</p>
<p><code>finally</code> 方法返回一个<code>Promise</code>。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。这为在<code>Promise</code>是否成功完成后都需要执行的代码提供了一种方式。</p>
<p><code>Promise</code>对象提供一个<code>all</code>方法，支持多个promise 处理，返回一个<code>Promise</code>对象。<code>all</code>接受一个<code>Promise</code>数组作为参数。当全部<code>Promise</code>状态都为成功时返回的<code>Promise</code>对象也会时成功状态并且<code>then</code>的成功回调函数接收成功值组成的一个数组，数组的每一个项与<code>Promise</code>数组一一对应。如果<code>Promise</code>数组中其中一个失败了，那么<code>all</code>返回的整个<code>Promise</code>对象也会被拒绝。</p>
<p><code>Promise</code>对象提供一个<code>race</code>方法,接受一个<code>Promise</code>数组，如果<code>Promise</code>数组有一个成功或失败了那么返回的<code>Promise</code>对象就会成功或拒绝。<code>race</code>会以一个成功或失败的<code>Promsie</code> 返回值作为整个<code>Promsie</code>的then中成功或失败回调的接受参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用Generator实现async await</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span> (<span class="params">generator</span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> iterator = generator();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(iterator)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> handle = <span class="function">(<span class="params">iteratorResult</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(iteratorResult.done) <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">const</span> iteratorValue = iteratorResult.value;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(iteratorValue <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            iteratorValue.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                handle(iterator.next(res));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            &#125;).catch(<span class="function"><span class="params">error</span> =&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                iterator.throw(error);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    handle(iterator.next())</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getJson</span>(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            resolve(<span class="string">'res'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> data = <span class="keyword">yield</span> getJson;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async'</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure>

</div><div class="tags"><a href="/tags/JavaScript/">JavaScript</a></div><div class="post-nav"><a class="pre" href="/2020/07/16/JavaScript%20%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%20%E7%AC%94%E8%AE%B0(%E4%B8%89)%20js%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/">JavaScript 忍者秘籍 阅读笔记(三)</a><a class="next" href="/2020/07/08/JavaScript%20%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%20%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">JavaScript 忍者秘籍 阅读笔记(二)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/CSV/" style="font-size: 15px;">CSV</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/Vue%E7%BB%84%E4%BB%B6/" style="font-size: 15px;">Vue组件</a> <a href="/tags/%E6%B7%B7%E5%85%A5/" style="font-size: 15px;">混入</a> <a href="/tags/%E6%8C%87%E4%BB%A4/" style="font-size: 15px;">指令</a> <a href="/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size: 15px;">过滤器</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/01/03/git%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/">git流程以及提交规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/14/React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/">React-组件通信</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/14/%E7%90%86%E8%A7%A3VirtualDOM%E4%BB%A5%E5%8F%8Adiff%E7%AE%97%E6%B3%95/">理解VirtualDOM以及diff算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/16/JavaScript%20%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%20%E7%AC%94%E8%AE%B0(%E4%B8%89)%20js%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/">JavaScript 忍者秘籍 阅读笔记(三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/JavaScript%20%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%20%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E5%87%BD%E6%95%B0/">JavaScript 忍者秘籍 阅读笔记(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/JavaScript%20%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%20%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">JavaScript 忍者秘籍 阅读笔记(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/14/%E6%B5%85%E8%B0%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/">浅谈js垃圾回收机制</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/05/ParseCsv/">利用PopParese上传下载csv文件</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/01/vue_cli_%20variable_module/">基于vue-cli 3.0实现一个工程多项目多模块打包</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/12/26/vue-conclusion/">Vue项目总结</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/." rel="nofollow">zZZ.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>