<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="只为做到今天离开这里，明天找到比这更好的"><title>理解VirtualDOM以及diff算法 | zZZ</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><meta name="generator" content="Hexo 4.0.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">理解VirtualDOM以及diff算法</h1><a id="logo" href="/.">zZZ</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/tags/"><i class="fa fa-tags"> 标签</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">理解VirtualDOM以及diff算法</h1><div class="post-meta">Aug 14, 2020<span> | </span><span class="category"><a href="/categories/Vue/">Vue</a></span></div><div class="post-content"><a id="more"></a>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>时至今日，前端领域内的mvvm框架也日渐成熟这其中也包括与之对应的VirtualDOM以及DOM-diff算法的发展。最近尤大推出了vue 3.0 beta 版其中也对VirtualDOM和DOM-diff进行了优化，借此机会我也回顾了VirtualDOM以及DOM-diff算法的发展历史同时实现了其中两种比较经典的diif算法。我一直坚信对外输出知识内容远比一个人闭门造车更重要，所以此文也是我在这一阶段学习内容的输出。</p>
<h3 id="什么是VirtualDOM？"><a href="#什么是VirtualDOM？" class="headerlink" title="什么是VirtualDOM？"></a>什么是VirtualDOM？</h3><p>VirtualDOM相信在现如今已经不再是生僻词汇，而VirtualDOM是我们理解diff过程的必备知识点。简单来理解虚拟DOM就是用js对象模拟出来的DOM树，它记录了DOM元素的标签名,属性,子节点等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">constructor</span>(type, props,children)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.type = type;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.props = props;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.children = children;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">this</span>.count = <span class="keyword">this</span>.CountChildren(children);<span class="comment">// 记录子节点个数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    CountChildren(children) &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">let</span> count = (children &amp;&amp; children.length) || <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; children.length; index++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(children[index] <span class="keyword">instanceof</span> Element)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">                count += children[index].count||<span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">return</span> count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props,children</span>)</span>&#123; <span class="comment">//生成VirtualDOM对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Element(type, props,children)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">h</span>) </span>&#123; <span class="comment">// 根据VirtualDOM对象构建对应DOM元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> dom =  <span class="built_in">document</span>.createElement(h.type);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> h.props) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (h.props.hasOwnProperty(key)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            setAttr(dom,key,h.props[key]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    h.children.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">let</span> child = item <span class="keyword">instanceof</span> Element? render(item) : 							<span class="built_in">document</span>.createTextNode(item);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        dom.appendChild(child);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> dom;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>我们定义一个<code>Element</code>的class类用来诠释VirtualDOM对象，并创建<code>render</code>函数将VirtualDOM对象生成对应的dom元素。</p>
<h3 id="为什么要需要VirtualDOM？"><a href="#为什么要需要VirtualDOM？" class="headerlink" title="为什么要需要VirtualDOM？"></a>为什么要需要VirtualDOM？</h3><p>既然虚拟DOM只是用js对象来描述真实dom那为什么不直接对DOM操作呢？如果在搜索引擎上查询这个问题会有大量的回答说dom操作是昂贵且慢的，VirtualDOM更快更便捷。</p>
<p>然后事实是在简单的DOM结构中如果是直接改变整个dom树那么直接操做DOM元素需要的是innerHtml + 重现所有DOM元素，这会比VirtualDOM+diff的操作更快。但是在一个大型列表中只有一行数据变化时VirtualDOM能够只更新变化的DOM元素并且避免整个页面的重制。重要的是相比于DOM操作js计算确实廉价得多。</p>
<p>在现代前端高速发展下，VirtualDOM也为我们提供了更多的可能，而不是局限于DOM一个端。比如ReactNative（ vue 2.0对于sanbbdom的引入, vue 3.0 将内部core的分离在我理解来都是有对多端需求的应对）</p>
<h3 id="diff算法找到差异"><a href="#diff算法找到差异" class="headerlink" title="diff算法找到差异"></a>diff算法找到差异</h3><p>在上述提到的数据更新时VirtualDOM的处理最重要的便是新旧两颗虚拟DOM树的对比，而这个对比的算法就被称为diff算法。最开始的diff算法是基于经典的深度优先搜索实现的，它会完全对比两颗树生成差异树，然后遍历差异树进行差异处理这是一个时间复杂度为O(n^3)的问题，但是在前端环境中很少会要跨层级的移动DOM元素。所以React有对这种算法进行优化只对比同级的DOM节点使其复杂度为O(n)。</p>
<p>利用这张经典的diff对比图能清晰的呈现对比的过程，对比只会发生在同层级，不会跨层级对比。</p>
<p><img src="/uploads/diff.png" alt="diff"></p>
<p> 比如在这样的两个虚拟DOM树对比中</p>
<img src="/uploads/diff1.jpg" alt="diff1" style="zoom:35%;" />

<p>最快的操作会是将<code>span</code>元素直接移到<code>p</code>标签后，可是实际的diif操作中会先删除<code>span</code>标签然后在<code>p</code>标签后插入一个<code>span</code>。</p>
<h4 id="具体的diif过程大致是如下"><a href="#具体的diif过程大致是如下" class="headerlink" title="具体的diif过程大致是如下"></a>具体的diif过程大致是如下</h4><ol>
<li><h3 id="深度优先搜索，找到差异节点并记录到一个对象中。"><a href="#深度优先搜索，找到差异节点并记录到一个对象中。" class="headerlink" title="深度优先搜索，找到差异节点并记录到一个对象中。"></a>深度优先搜索，找到差异节点并记录到一个对象中。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> diff = <span class="function">(<span class="params">oldTree, newTree</span>) =&gt;</span>&#123; <span class="comment">// diff 对比两颗树</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> patches = &#123;&#125;; <span class="comment">// 记录需要更改的节点以及内容</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>; <span class="comment">// 从VNode树的根节点开始记录</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    treeWalker(oldTree, newTree, index,patches);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> patches;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * REMOVE 删除节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * TEXT 节点文本内容改变</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * TYPE 节点属性发生变化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * REPLACE 节点被替换</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> * INSERT  插入新节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"> */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> treeWalker = <span class="function">(<span class="params">oldTree, newTree, index, patches</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 传统的diff算法，遍历递归新旧两棵dom树对比得到最少操作，所以会有O(n^3);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * react和vue的diff 思路</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 对比同层的节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 1. 如果没有newTree说明旧节点已经被删除</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 2. 判断新旧节点是否为string，如果都为string且不同，说明是节点文本内容发生改变</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 3. 根据type是否一致判断节点是否被整体替换。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     * 将每一个节点存在都变化都存放在patches大对象中，并以树的索引为key</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">     */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> current = [];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!newTree)&#123; <span class="comment">// 新的树上没有说明需要删除就旧节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        current.push(&#123;<span class="attr">key</span>: <span class="string">'REMOVE'</span>, index&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(isString(oldTree) &amp;&amp; isString(newTree))&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(oldTree !== newTree)&#123; <span class="comment">// 都为string类型并且存在差异说明文本发生变化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            current.push(&#123;<span class="attr">key</span>: <span class="string">'TEXT'</span>, newTree&#125;); </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(oldTree.type == newTree.type) &#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">let</span> attr = diffAttr(oldTree.props, newTree.props);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(attr).length&gt;<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">            current.push(&#123;<span class="attr">key</span>: <span class="string">'TYPE'</span>, attr&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        childrenDiff(oldTree.children,newTree.children, current,index,patches);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 不是文本类型，tagName也不同，那么说明需要替换旧节点</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        current.push(&#123;<span class="attr">key</span>: <span class="string">'REPLACE'</span>, newTree&#125;);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(current.length)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        patches[index] = current;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childrenDiff = <span class="function">(<span class="params">oldTreeChildren, newTreeChildren,current,index,patches</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    oldChildrenLng = oldTreeChildren.length ?  oldTreeChildren.length: <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    NewChildrenLng = newTreeChildren.length ? newTreeChildren.length:  <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">let</span> count = <span class="built_in">Math</span>.max(oldChildrenLng,NewChildrenLng) <span class="comment">// 根据最长的子节点来遍历递归判断处理</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">var</span> oldNode = oldTreeChildren[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">var</span> newVNode = newTreeChildren[i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">        index += <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(!leftNode)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span>(rightNode)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">                current.push(&#123;<span class="attr">key</span>: <span class="string">'INSERT'</span>,newVNode&#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">            treeWalker(leftNode,rightNode, index,patches);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span>(leftNode <span class="keyword">instanceof</span> Element &amp;&amp; leftNode.count)&#123; <span class="comment">// 删除节点并不会再遍历其下级节点，所以这里索引加上下级节点数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">            index += leftNode.count;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>还是引用上面的例子，通过diff函数能得到一个<code>patches</code>对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patches = &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    <span class="number">0</span>:[&#123;<span class="attr">key</span>: <span class="string">'INSERT'</span>,<span class="attr">newVNode</span>: difference&#125;],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="number">4</span>:[&#123;<span class="attr">key</span>: <span class="string">'REMOVE'</span>,<span class="attr">index</span>: <span class="number">4</span>&#125;]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>比如，span被删除会以其索引4为标记，并用数组存储节点的不同。数组中的每一个值几率当前标记节点的新旧差异。</p>
<p>但是怎么表示这些差异呢？我们将提前定义好差异类型用来对应可能出现的DOM操作：</p>
<ul>
<li><p>替换原来节点。=&gt; <code>REPLACE</code></p>
</li>
<li><p>插入新节点。=&gt; <code>INSERT</code></p>
</li>
<li><p>删除旧节点。 =&gt; <code>REMOVE</code></p>
</li>
<li><p>节点属性修改。 =&gt; <code>TYPE</code></p>
</li>
<li><p>标签文本内容修改。 =&gt; <code>TEXT</code></p>
</li>
</ul>
<p>如果是节点属性修改就纪录下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pacthes[<span class="number">0</span>] = [&#123;<span class="attr">key</span>: <span class="string">'TYPE'</span>, <span class="attr">props</span>:&#123;<span class="attr">id</span>: <span class="string">'App'</span>&#125;] <span class="comment">// 比如id修改</span></span></pre></td></tr></table></figure>

<p>如果是替换节点会记录：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">paches[<span class="number">1</span>] = [&#123;<span class="attr">key</span>: <span class="string">'REPLACE'</span>, newTree&#125;] <span class="comment">// newTree 为新节点的Element对象</span></span></pre></td></tr></table></figure>

<p>但是当节点树只是顺序上发生变化时会怎么对比呢？如果以现在同层级间进行顺序上对比的话，如果是type值不同及tagName不同会用新的替换旧节点，如果是tagName相同的话会深度遍历其子节点，并对其进行修改或替换。这样来看由于有多个替换修改对DOM的消耗将会很大。如果我们构建子节点的Element对象是插入唯一标识就可以在对比是复用DOM树上的节点，这里我们为了更好理解VirtualDOM与VirtualDOM diff过程先不加入唯一标识的列表对比。</p>
</li>
<li><h3 id="将差异构建到真实的dom树上"><a href="#将差异构建到真实的dom树上" class="headerlink" title="将差异构建到真实的dom树上"></a>将差异构建到真实的dom树上</h3><p>在构建Element对象后我们利用render函数生成了对应的DOM树，他们的结构和信息大致一样。这样我们可以直接对生成的真的DOM树直接深层遍历，并且遍历时可以在diif过程中构建的<code>pacthes</code>对象中查找当前遍历节点是否存在差异，存在差异的情况下纪录所需要操作的dom节点，并进行dom操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> vpatch = [];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> patch = <span class="function">(<span class="params">node, patches</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> walker = &#123;<span class="attr">index</span>: <span class="number">0</span>&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    walk(node,walker,patches);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    applyPatch(vpatch)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> walk = <span class="function">(<span class="params">node,walker,patches</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> current = patches[walker.index];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">var</span> len = (node &amp;&amp; node.childNodes)? node.childNodes.length : <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">var</span> child = node.childNodes[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        walker.index++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        walk(child,walker,patches)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(current)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        current.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            item[<span class="string">'el'</span>] = node; <span class="comment">// 如果存在差异，记录需要操作节点的dom元素</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        vpatch.push(current);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> applyPatch = <span class="function">(<span class="params">vpatch</span>) =&gt;</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;vpatch.length; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        doPatch(vpatch[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p><code>doPacth</code> 将会根据记录的差异类型对真实DOM进行对应操作</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doPatch = <span class="function">(<span class="params">current</span>) =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">    current.forEach(<span class="function"><span class="params">patch</span> =&gt;</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">let</span> &#123;el&#125; = patch;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">let</span> node  = el;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">switch</span>(patch.key)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'TEXT'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">                node.textContent = patch.newTree;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'REMOVE'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">                node.parentNode.removeChild(node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'REPLACE'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">let</span> newNode = patch.newTree;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">                newNode = (newNode <span class="keyword">instanceof</span> Element) ? render(newNode) : <span class="built_in">document</span>.createTextNode(newNode);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">                node.parentNode.replaceChild(newNode, node);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'TYPE'</span>: </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> patch.attr) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">let</span> value = patch.attr[key];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">                    <span class="keyword">if</span>(value)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">                        setAttr(node,key,value)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">                        node.removeAttr(key);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">case</span> <span class="string">'INSERT'</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">                node.appendChild(render(patch.newVNode))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">default</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">                <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">            </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    &#125;)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>到这里VirtualDOM diff 的整个过程也就完成了。目前实现的只是非常基础的版本，没有对dom事件的代理没有加入key的排序优化。但是这一整套实现下来让我对<code>React</code>,<code>vue</code>的diff算法和模版编译的理解有很大的帮助，其实现在这篇文章所实现的diff算法与React15x 的diif 算法核心是非常相似的。</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    这是第一篇自我驱动学习并对外输出对文章，虽然断断续续学习写文章用了不少时间，但是收获远大于付出。虽然文章可能还有许多不足，但也需要这边文章能帮到看到文章的人。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://segmentfault.com/a/1190000011235844" target="_blank" rel="noopener">去哪儿网迷你React的研发心得</a><br><a href="https://github.com/livoras/blog/issues/13" target="_blank" rel="noopener">如何实现一个 Virtual DOM 算法</a></p>
</div><div class="tags"><a href="/tags/Vue/">Vue</a></div><div class="post-nav"><a class="pre" href="/2020/12/14/React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/">React-组件通信</a><a class="next" href="/2020/07/16/JavaScript%20%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%20%E7%AC%94%E8%AE%B0(%E4%B8%89)%20js%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/">JavaScript 忍者秘籍 阅读笔记(三)</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/React/">React</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vue/">Vue</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/">webpack</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/webpack/vite/">vite</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">前端工程化</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">阅读笔记</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/CSV/" style="font-size: 15px;">CSV</a> <a href="/tags/webpack/" style="font-size: 15px;">webpack</a> <a href="/tags/Vue/" style="font-size: 15px;">Vue</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/Vue%E7%BB%84%E4%BB%B6/" style="font-size: 15px;">Vue组件</a> <a href="/tags/%E6%B7%B7%E5%85%A5/" style="font-size: 15px;">混入</a> <a href="/tags/%E6%8C%87%E4%BB%A4/" style="font-size: 15px;">指令</a> <a href="/tags/%E8%BF%87%E6%BB%A4%E5%99%A8/" style="font-size: 15px;">过滤器</a> <a href="/tags/vlc/" style="font-size: 15px;">vlc</a> <a href="/tags/%E5%94%A4%E8%B5%B7%E6%9C%AC%E5%9C%B0%E5%BA%94%E7%94%A8/" style="font-size: 15px;">唤起本地应用</a> <a href="/tags/%E4%BC%98%E5%8C%96/" style="font-size: 15px;">优化</a> <a href="/tags/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/" style="font-size: 15px;">渲染优化</a> <a href="/tags/vite/" style="font-size: 15px;">vite</a> <a href="/tags/rullp/" style="font-size: 15px;">rullp</a> <a href="/tags/%E6%97%A5%E5%B8%B8/" style="font-size: 15px;">日常</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/08/01/%E4%B8%80%E4%BA%9B%E7%A8%80%E5%A5%87%E5%8F%A4%E6%80%AA%E7%9A%84%E8%AE%B0%E5%BD%95/">前端渲染优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/07/21/web%E9%A1%B5%E6%89%93%E5%BC%80%E6%9C%AC%E5%9C%B0vlc%E5%BA%94%E7%94%A8/">web页打开本地vlc应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/21/%E6%B8%B2%E6%9F%93%E4%BC%98%E5%8C%96/">前端渲染优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2022/10/11/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83%E6%BC%94%E5%8C%96/">前端构建演化</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/03/git%E6%B5%81%E7%A8%8B%E4%BB%A5%E5%8F%8A%E6%8F%90%E4%BA%A4%E8%A7%84%E8%8C%83/">git流程以及提交规范</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/14/React-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/">React-组件通信</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/14/%E7%90%86%E8%A7%A3VirtualDOM%E4%BB%A5%E5%8F%8Adiff%E7%AE%97%E6%B3%95/">理解VirtualDOM以及diff算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/16/JavaScript%20%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%20%E7%AC%94%E8%AE%B0(%E4%B8%89)%20js%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/">JavaScript 忍者秘籍 阅读笔记(三)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/JavaScript%20%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%20%E7%AC%94%E8%AE%B0(%E4%BA%8C)%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">JavaScript 忍者秘籍 阅读笔记(二)</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/07/08/JavaScript%20%E5%BF%8D%E8%80%85%E7%A7%98%E7%B1%8D%20%E7%AC%94%E8%AE%B0(%E4%B8%80)%20%E5%87%BD%E6%95%B0/">JavaScript 忍者秘籍 阅读笔记(一)</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">zZZ.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>